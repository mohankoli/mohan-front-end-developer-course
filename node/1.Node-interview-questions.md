# Node.js Senior Interview Preparation (12+ Years Level)

## ✅ Topics Covered

### 1. Node.js Concurrency & Event Loop
- Node.js is single-threaded for JavaScript execution
- Uses non-blocking I/O and event-driven architecture
- Async tasks delegated to OS or libuv thread pool
- Event loop phases:
  - Timers
  - I/O callbacks
  - Poll
  - Check
  - Close callbacks
- Enables high concurrency with a single JS thread

---

### 2. process.nextTick() vs Promise.then()
- process.nextTick():
  - Highest priority in Node.js
  - Executes immediately after the current call stack
  - Runs before the event loop continues
  - Can starve the event loop if overused
- Promise.then():
  - Part of the microtask queue
  - Executes after process.nextTick
  - Runs before macrotasks (timers, I/O)
- Execution order:
  - sync → process.nextTick → Promise.then → timers

---

### 3. Blocking the Event Loop
- Blocking the event loop makes Node.js slow or completely unresponsive
- While blocked, Node cannot process new requests, timers, or I/O callbacks
- Real production blocking examples:
  - CPU-heavy loops
  - Deep JSON.parse / JSON.stringify
  - Catastrophic regular expressions
  - Synchronous file system calls
  - Compression / encryption on large data
- Solutions:
  - Prefer async APIs over sync ones
  - Use streams for large data processing
  - Offload CPU work to Worker Threads
  - Use child processes for isolation
  - Scale horizontally using cluster

---

### 4. Cluster vs Worker Threads
- Cluster:
  - Process-based architecture
  - Each worker has its own event loop and memory
  - Best suited for handling high I/O traffic
  - Utilizes multiple CPU cores by spawning multiple processes
- Worker Threads:
  - Thread-based parallelism
  - Shared memory support
  - Best suited for CPU-intensive tasks
- Usage:
  - Cluster → scalability and throughput
  - Worker Threads → performance and computation

---

### 5. libuv Internals
- libuv is a C-based, cross-platform open-source library
- It provides:
  - Event loop implementation
  - Asynchronous I/O
  - Thread pool management
- Handles:
  - File system operations
  - DNS lookups
  - Crypto operations
  - Timers and polling
- Abstracts OS-level async behavior across platforms

---

### 6. CPU-Intensive Tasks in Node.js
- Node.js is not suitable for CPU-intensive tasks by default
- CPU-heavy operations block the single JS thread
- Common examples:
  - Image processing
  - Encryption / decryption
  - Heavy mathematical calculations
- Solutions:
  - Use Worker Threads for parallel computation
  - Use child processes for isolation
  - Offload work to external services
  - Use cluster for traffic distribution, not computation

---

### 7. Backpressure in Streams
- Backpressure occurs when a data producer is faster than the consumer
- Common in read and write stream scenarios
- If not handled, it can lead to memory overflow
- Node.js streams handle backpressure automatically
- Key mechanisms:
  - stream.pipe() automatically manages flow control
  - highWaterMark controls internal buffer size
  - write() return value indicates buffer state
  - drain event signals when to resume writing
- Prevents excessive memory usage in production

---

### 8. setImmediate() vs setTimeout(fn, 0)
- setImmediate():
  - Executes in the **check phase** of the event loop
  - Runs immediately after I/O callbacks
  - Ideal when you want a callback to run right after an I/O operation
- setTimeout(fn, 0):
  - Executes in the **timers phase**
  - Subject to a minimum delay, not guaranteed to run immediately
- Key difference:
  - setImmediate is more predictable inside I/O callbacks
  - setTimeout(0) depends on timer scheduling and delays
- Best practice:
  - Prefer setImmediate() inside I/O callbacks for faster execution
