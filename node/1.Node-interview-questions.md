# Node.js Senior Interview Preparation (12+ Years Level)

## ✅ Topics Covered

### 1. Node.js Concurrency & Event Loop
- Node.js is single-threaded for JavaScript execution
- Uses non-blocking I/O and event-driven architecture
- Async tasks delegated to OS or libuv thread pool
- Event loop phases:
  - Timers
  - I/O callbacks
  - Poll
  - Check
  - Close callbacks
- Enables high concurrency with a single JS thread

---

### 2. process.nextTick() vs Promise.then()
- process.nextTick():
  - Highest priority
  - Executes immediately after current call stack
  - Can starve event loop if misused
- Promise.then():
  - Microtask queue
  - Executes after nextTick but before macrotasks
- Execution order:
  - sync → nextTick → promise → timers

---

### 3. Blocking the Event Loop
- Causes Node.js server to become slow or unresponsive
- Real blocking examples:
  - CPU-heavy loops
  - Deep JSON.parse / JSON.stringify
  - Catastrophic regex
  - Synchronous file system calls
  - Compression / encryption
- Solutions:
  - Use async APIs
  - Streams for large data
  - Worker Threads
  - Child processes
  - Horizontal scaling (cluster)

---

### 4. Cluster vs Worker Threads
- Cluster:
  - Process-based
  - Separate memory
  - Best for high I/O traffic
  - Utilizes multiple CPU cores
- Worker Threads:
  - Thread-based
  - Shared memory
  - Best for CPU-intensive tasks
- Usage:
  - Cluster → scalability
  - Worker Threads → performance

---

### 5. libuv Internals
- C-based, cross-platform library
- Provides:
  - Event loop
  - Async I/O
  - Thread pool
- Handles:
  - File system
  - DNS
  - Crypto
  - Timers
- Abstracts OS-level async behavior

---

### 6. CPU-Intensive Tasks in Node.js
- Node.js is not CPU-friendly by default
- CPU work blocks event loop
- Examples:
  - Image processing
  - Encryption
  - Heavy calculations
- Solutions:
  - Worker Threads
  - Child processes
  - External services
  - Cluster for traffic distribution

---

### 7. Backpressure in Streams
- Occurs when producer is faster than consumer
- Common in read/write streams
- Node.js handles backpressure automatically
- Tools:
  - stream.pipe()
  - highWaterMark
  - write() return value
  - drain event
- Prevents memory overflow

---

### 8. setImmediate() vs setTimeout(fn, 0)
- setImmediate():
  - Runs in check phase
  - Executes after I/O callbacks
- setTimeout(fn, 0):
  - Runs in timers phase
  - Minimum delay applied
- Prefer setImmediate inside I/O callbacks
